##   Copyright (c) Eduardo Julian. All rights reserved.
##   The use and distribution terms for this software are covered by the
##   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
##   which can be found in the file epl-v10.html at the root of this distribution.
##   By using this software in any fashion, you are agreeing to be bound by
##   the terms of this license.
##   You must not remove this notice, or any other, from this software.

(;import lux
         (.. (macro #as m #refer #all)
             lux)
         (lux (control (functor #as F)
                       (monad #as M #refer (#only do)))
              (data list)))

## [Utils]
(def (first xy)
  (All [a b] (-> (, a b) a))
  (let [[x y] xy]
    x))

## Types
(deftype #export (Parser a)
  (-> (List Syntax) (Maybe (, (List Syntax) a))))

## Structures
(defstruct #export Parser:Functor (F;Functor Parser)
  (def (F;map f ma)
    (lambda [tokens]
      (case (ma tokens)
        #;None
        #;None

        (#;Some [tokens' a])
        (#;Some [tokens' (f a)])))))

(defstruct #export Parser:Monad (M;Monad Parser)
  (def M;_functor Parser:Functor)

  (def (M;wrap x tokens)
    (#;Some [tokens x]))

  (def (M;join mma)
    (lambda [tokens]
      (case (mma tokens)
        #;None
        #;None

        (#;Some [tokens' ma])
        (ma tokens')))))

## Parsers
(def #export (id^ tokens)
  (Parser Syntax)
  (case tokens
    #;Nil                #;None
    (#;Cons [t tokens']) (#;Some [tokens' t])))

(do-template [<name> <type> <tag>]
  [(def #export (<name> tokens)
     (Parser <type>)
     (case tokens
       (#;Cons [(#;Meta [_ (<tag> x)]) tokens'])
       (#;Some [tokens' x])

       _
       #;None))]

  [  bool^ Bool  #;BoolS]
  [   int^ Int   #;IntS]
  [  real^ Real  #;RealS]
  [  char^ Char  #;CharS]
  [  text^ Text  #;TextS]
  [symbol^ Ident #;SymbolS]
  [   tag^ Ident #;TagS]
  )

(def (bool:= x y)
  (-> Bool Bool Bool)
  (if x
    y
    (not y)))

(def (ident:= x y)
  (-> Ident Ident Bool)
  (let [[x1 x2] x
        [y1 y2] y]
    (and (text:= x1 y1)
         (text:= x2 y2))))

(do-template [<name> <type> <tag> <eq>]
  [(def #export (<name> v tokens)
     (-> <type> (Parser (,)))
     (case tokens
       (#;Cons [(#;Meta [_ (<tag> x)]) tokens'])
       (if (<eq> v x)
         (#;Some [tokens' []])
         #;None)

       _
       #;None))]

  [  bool?^ Bool    #;BoolS  bool:=]
  [   int?^ Int      #;IntS   int:=]
  [  real?^ Real    #;RealS  real:=]
  ## [  char?^ Char    #;CharS  char:=]
  [  text?^ Text    #;TextS  text:=]
  [symbol?^ Ident #;SymbolS ident:=]
  [   tag?^ Ident    #;TagS ident:=]
  )

(do-template [<name> <tag>]
  [(def #export (<name> p tokens)
     (All [a]
       (-> (Parser a) (Parser a)))
     (case tokens
       (#;Cons [(#;Meta [_ (<tag> form)]) tokens'])
       (case (p form)
         (#;Some [#;Nil x]) (#;Some [tokens' x])
         _                  #;None)

       _
       #;None))]

  [ form^  #;FormS]
  [tuple^ #;TupleS]
  )

(def #export (?^ p tokens)
  (All [a]
    (-> (Parser a) (Parser (Maybe a))))
  (case (p tokens)
    #;None               (#;Some [tokens #;None])
    (#;Some [tokens' x]) (#;Some [tokens' (#;Some x)])))

(def (run-parser p tokens)
  (All [a]
    (-> (Parser a) (List Syntax) (Maybe (, (List Syntax) a))))
  (p tokens))

(def #export (*^ p tokens)
  (All [a]
    (-> (Parser a) (Parser (List a))))
  (case (p tokens)
    #;None               (#;Some [tokens (list)])
    (#;Some [tokens' x]) (run-parser (do Parser:Monad
                                       [xs (*^ p)]
                                       (M;wrap (list& x xs)))
                                     tokens')))

(def #export (+^ p)
  (All [a]
    (-> (Parser a) (Parser (List a))))
  (do Parser:Monad
    [x p
     xs (*^ p)]
    (M;wrap (list& x xs))))

(def #export (&^ p1 p2)
  (All [a b]
    (-> (Parser a) (Parser b) (Parser (, a b))))
  (do Parser:Monad
    [x1 p1
     x2 p2]
    (M;wrap [x1 x2])))

(def #export (|^ p1 p2 tokens)
  (All [a b]
    (-> (Parser a) (Parser b) (Parser (Either b))))
  (case (p1 tokens)
    (#;Some [tokens' x1]) (#;Some [tokens' (#;Left x1)])
    #;None                (run-parser (do Parser:Monad
                                        [x2 p2]
                                        (M;wrap (#;Right x2)))
                                      tokens)))

(def #export (||^ ps tokens)
  (All [a]
    (-> (List (Parser a)) (Parser (Maybe a))))
  (case ps
    #;Nil            #;None
    (#;Cons [p ps']) (case (p tokens)
                       #;None               (||^ ps' tokens)
                       (#;Some [tokens' x]) (#;Some [tokens' (#;Some x)]))
    ))

(def #export (end^ tokens)
  (Parser (,))
  (case tokens
    #;Nil      (#;Some [tokens []])
    _          #;None))

## Syntax
(defmacro #export (defsyntax tokens)
  (case tokens
    (\ (list (#;Meta [_ (#;FormS (list& (#;Meta [_ (#;SymbolS ["" name])]) args))])
             body))
    (do Lux:Monad
      [names+parsers (M;map% Lux:Monad
                             (: (-> Syntax (Lux (, Syntax Syntax)))
                                (lambda [arg]
                                  (case arg
                                    (\ (#;Meta [_ (#;TupleS (list (#;Meta [_ (#;SymbolS var-name)])
                                                                  parser))]))
                                    (M;wrap [(symbol$ var-name) parser])

                                    _
                                    (fail "Syntax pattern expects 2-tuples."))))
                             args)
       g!tokens (gensym "tokens")
       #let [names (:: F;List:Functor (F;map first names+parsers))
             error-msg (text$ (text:++ "Wrong syntax for " name))
             parsing (foldL (: (-> Syntax (, Syntax Syntax) Syntax)
                               (lambda [body name+parser]
                                 (let [[name parser] name+parser]
                                   (` (_lux_case ((~ parser) (~ g!tokens))
                                        (#;Some [(~ g!tokens) (~ name)])
                                        (~ body)

                                        _
                                        #;None)))))
                            (: Syntax (` (#;Some [(~@ names)])))
                            (reverse names+parsers))
             body' (: Syntax
                      (` (_lux_case (~ parsing)
                           (#;Some [#;Nil [(~@ names)]])
                           (~ body)

                           _
                           (l;fail (~ (text$ (text:++ "Wrong syntax for " name)))))))
             macro-def (: Syntax
                          (` (m/defmacro ((~ (symbol$ ["" name])) (~ g!tokens))
                               (~ body'))))]]
      (M;wrap (list macro-def)))
    
    _
    (fail "Wrong syntax for defsyntax")))
