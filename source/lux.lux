## Base interfaces & classes
(jvm:interface Function
               (: apply (-> [java.lang.Object] java.lang.Object)))

(jvm:class Tuple0 java.lang.Object
           [])
(jvm:class Tuple1 java.lang.Object
           [[java.lang.Object _1]])
(jvm:class Tuple2 java.lang.Object
           [[java.lang.Object _1] [java.lang.Object _2]])
(jvm:class Tuple3 java.lang.Object
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3]])
(jvm:class Tuple4 java.lang.Object
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3] [java.lang.Object _4]])
(jvm:class Tuple5 java.lang.Object
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3] [java.lang.Object _4]
            [java.lang.Object _5]])
(jvm:class Tuple6 java.lang.Object
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3] [java.lang.Object _4]
            [java.lang.Object _5] [java.lang.Object _6]])
(jvm:class Tuple7 java.lang.Object
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3] [java.lang.Object _4]
            [java.lang.Object _5] [java.lang.Object _6]
            [java.lang.Object _7]])
(jvm:class Tuple8 java.lang.Object
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3] [java.lang.Object _4]
            [java.lang.Object _5] [java.lang.Object _6]
            [java.lang.Object _7] [java.lang.Object _8]])

(jvm:class Variant java.lang.Object
           [[java.lang.String tag]])
(jvm:class Variant0 lux.Variant
           [])
(jvm:class Variant1 lux.Variant
           [[java.lang.Object _1]])
(jvm:class Variant2 lux.Variant
           [[java.lang.Object _1] [java.lang.Object _2]])
(jvm:class Variant3 lux.Variant
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3]])
(jvm:class Variant4 lux.Variant
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3] [java.lang.Object _4]])
(jvm:class Variant5 lux.Variant
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3] [java.lang.Object _4]
            [java.lang.Object _5]])
(jvm:class Variant6 lux.Variant
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3] [java.lang.Object _4]
            [java.lang.Object _5] [java.lang.Object _6]])
(jvm:class Variant7 lux.Variant
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3] [java.lang.Object _4]
            [java.lang.Object _5] [java.lang.Object _6]
            [java.lang.Object _7]])
(jvm:class Variant8 lux.Variant
           [[java.lang.Object _1] [java.lang.Object _2]
            [java.lang.Object _3] [java.lang.Object _4]
            [java.lang.Object _5] [java.lang.Object _6]
            [java.lang.Object _7] [java.lang.Object _8]])

## Base functions & macros
(def' id
  (lambda' id x
      x))

(def' + (lambda' + x (lambda' _ y (jvm:iadd x y))))

(def' fold
  (lambda' fold f
      (lambda' _ init
          (lambda' _ values
              (case values
                #Nil
                init
                (#Cons x xs)
                (fold f (f init x) xs)
                )))))

(annotate lambda Macro)
(def' lambda
  (lambda' _ tokens
      (case tokens
        (#Cons self (#Cons (#Tuple (#Cons arg args')) (#Cons body #Nil)))
        (#Form (#Cons (#Ident "lambda'")
                      (#Cons self
                             (#Cons arg
                                    (case args'
                                      #Nil
                                      (#Cons body #Nil)

                                      _
                                      (#Cons (#Ident "lux:lambda")
                                             (#Cons (#Tuple args')
                                                    (#Cons body #Nil))))))))
        
        (#Cons (#Tuple (#Cons arg args')) (#Cons body #Nil))
        (#Form (#Cons (#Ident "lambda'")
                      (#Cons (#Ident "_")
                             (#Cons arg
                                    (case args'
                                      #Nil
                                      (#Cons body #Nil)

                                      _
                                      (#Cons (#Ident "lux:lambda")
                                             (#Cons (#Tuple args')
                                                    (#Cons body #Nil))))))))
        )))

#(
  (defmacro (lambda tokens)
    (case tokens
      (#Cons self (#Cons args (#Cons body #Nil)))
      
      
      (#Cons args (#Cons body #Nil))
      ))
  
  (def' id (lambda [x] x))
  
  (def' + (lambda [x y] (jvm:iadd x y)))
  
  (def (fold f init values)
    (case values
      #Nil
      init
      (#Cons x xs)x
      (fold f (f init x) xs)))

  (def (cons tail head)
    (#Cons head tail))

  (def (reverse list)
    (fold cons #Nil list))

  (annotate list Macro)
  (def (list xs)
    (fold (lambda' tail
              (lambda' head
                  (#Form (#Cons (#Tag "Cons")
                                (#Cons head
                                       (#Cons tail #Nil))))))
          (#Tag "Nil")
          (reverse xs)))

  (def (++ xs ys)
    (case xs
      #Nil
      ys

      (#Cons x xs*)
      (#Cons x (++ xs* ys))))

  (def (map f xs)
    (case xs
      #Nil
      #Nil

      (#Cons x xs*)
      (#Cons (f x) (map f xs*))))

  (def (untemplate-list untemplate tokens)
    (case tokens
      #Nil
      (#Tag "Nil")

      (#Cons token tokens')
      (#Form (list (#Tag "Cons") (untemplate token) (untemplate-list untemplate tokens')))))

  (def (untemplate token)
    (case token
      (#Bool elem)
      (#Form (list (#Tag "Bool") (#Bool elem)))

      (#Int elem)
      (#Form (list (#Tag "Int") (#Int elem)))

      (#Real elem)
      (#Form (list (#Tag "Real") (#Real elem)))

      (#Char elem)
      (#Form (list (#Tag "Char") (#Char elem)))

      (#Text elem)
      (#Form (list (#Tag "Text") (#Text elem)))

      (#Tag elem)
      (#Form (list (#Tag "Tag") (#Text elem)))

      (#Ident elem)
      (#Form (list (#Tag "Ident") (#Text elem)))

      (#Form (#Cons (#Ident "~") (#Cons unquoted #Nil)))
      unquoted

      (#Tuple elems)
      (#Form (list (#Tag "Tuple") (untemplate-list untemplate elems)))

      (#Form elems)
      (#Form (list (#Tag "Form") (untemplate-list untemplate elems)))
      ))


  ## I/O
     (def (print x)
       (jvm:invokevirtual java.io.PrintStream "print" [Object]
                          (jvm:getstatic System out) [x]))

     (def (println x)
       (jvm:invokevirtual java.io.PrintStream "println" [Object]
                          (jvm:getstatic System out) [x]))

     (annotate ' Macro)
     (def (' form)
       (case form
         (#Cons token #Nil)
         (untemplate token)))

     (def (+ x y)
       (jvm:iadd x y))

     (def inc (+ 1))

     (def length (fold (lambda' l (lambda' x (inc l))) 0))

     (def (rem dividend divisor)
       (jvm:irem dividend divisor))

     (def (= x y)
       (jvm:invokevirtual Object "equals" [Object]
                          x [y]))

     (def (pairs list)
       (case list
         (#Cons x (#Cons y list*))
         (#Cons [x y] (pairs list*))

         _
         #Nil))

     (def (show x)
       (jvm:invokevirtual Object "toString" []
                          x []))

     (def (concat t1 t2)
       (jvm:invokevirtual String "concat" [String]
                          t1 [t2]))

     (def (range from to)
       (if (= from to)
         #Nil
         (#Cons from (range (inc from) to))))

     (def (text->list text)
       (let length (jvm:invokevirtual String "length" []
                                      text [])
            (map (lambda' idx
                          (jvm:invokevirtual String "charAt" [int]
                                             text [idx]))
                 (range 0 length))))

     (def (enumerate list)
       (case (fold (lambda' state
                            (lambda' x
                                     (case state
                                       [idx list']
                                       [(inc idx) (#Cons [idx x] list')])))
                   [0 #Nil]
                   list)
         [_ list']
         (reverse list')))

     (def list-map #Nil)

     (def (put key val map)
       (case map
         #Nil
         (#Cons [key val] map)

         (#Cons [?key ?val] map')
         (if (= key ?key)
           (#Cons [?key val] map')
           (#Cons [?key ?val] (put key val map')))))

     (def (get key map)
       (case map
         #Nil
         #None
         
         (#Cons [?key ?val] map')
         (if (= key ?key)
           (#Some ?val)
           (get key map'))))

     (def (show-kv kv)
       (case kv
         [?key ?val]
         (fold concat "" (list "#" ?key " " (show ?val)))))

     (def (interpose elem list)
       (case list
         (#Cons x (#Cons y list'))
         (#Cons x (#Cons elem (#Cons y list')))

         _
         list))

     (def (show-list xs)
       (case xs
         #Nil
         "#Nil"
         (#Cons x xs')
         (fold concat "" (list "(#Cons " (show x) " " (show-list xs') ")"))))

     )#
