##  Copyright (c) Eduardo Julian. All rights reserved.
##  This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
##  If a copy of the MPL was not distributed with this file,
##  You can obtain one at http://mozilla.org/MPL/2.0/.

(;import lux
         (lux (control (monoid #as m)
                       (functor #as F)
                       (monad #as M #refer (#only do seq%)))
              (data (list #refer #all #open ("" List/Functor List/Fold))
                    (number/int #refer #all #open ("i:" Int/Ord))
                    maybe
                    tuple)
              (meta lux
                    ast
                    syntax)))

(open List/Monad "list:")

## [Utils]
## Parsers
(def method-decl^
  (Parser (, (List Text) Text (List Text) Text))
  (form^ (do Parser/Monad
           [modifiers (*^ local-tag^)
            name local-symbol^
            inputs (tuple^ (*^ local-symbol^))
            output local-symbol^]
           (wrap [modifiers name inputs output]))))

(def field-decl^
  (Parser (, (List Text) Text Text))
  (form^ (do Parser/Monad
           [modifiers (*^ local-tag^)
            name local-symbol^
            class local-symbol^]
           (wrap [modifiers name class]))))

(def arg-decl^
  (Parser (, Text Text))
  (form^ (do Parser/Monad
           [arg-name local-symbol^
            arg-class local-symbol^]
           (wrap [arg-name arg-class]))))

(def method-def^
  (Parser (, (List Text) Text (List (, Text Text)) Text AST))
  (form^ (do Parser/Monad
           [modifiers (*^ local-tag^)
            name local-symbol^
            inputs (tuple^ (*^ arg-decl^))
            output local-symbol^
            body id^]
           (wrap [modifiers name inputs output body]))))

(def opt-arg^
  (Parser (, Bool Text))
  (&^ (tag?^ ["" "?"])
      local-symbol^))

## [Syntax]
(defsyntax #export (definterface [name local-symbol^] [supers (tuple^ (*^ local-symbol^))] [members (*^ method-decl^)])
  (let [members' (map (: (-> (, (List Text) Text (List Text) Text) AST)
                         (lambda [member]
                           (let [[modifiers name inputs output] member]
                             (` ((~ (text$ name)) [(~@ (map text$ inputs))] (~ (text$ output)) [(~@ (map text$ modifiers))])))))
                      members)]
    (emit (@list (` (;_jvm_interface (~ (text$ name)) [(~@ (map text$ supers))]
                                     (~@ members')))))))

(defsyntax #export (defclass [name local-symbol^] [super local-symbol^] [interfaces (tuple^ (*^ local-symbol^))]
                     [fields (*^ field-decl^)]
                     [methods (*^ method-def^)])
  (do Lux/Monad
    [current-module get-module-name
     #let [fields' (map (: (-> (, (List Text) Text Text) AST)
                           (lambda [field]
                             (let [[modifiers name class] field]
                               (` ((~ (text$ name))
                                   (~ (text$ class))
                                   [(~@ (map text$ modifiers))])))))
                        fields)
           methods' (map (: (-> (, (List Text) Text (List (, Text Text)) Text AST) AST)
                            (lambda [methods]
                              (let [[modifiers name inputs output body] methods]
                                (` ((~ (text$ name))
                                    [(~@ (map (: (-> (, Text Text) AST)
                                                 (lambda [in]
                                                   (let [[left right] in]
                                                     (form$ (@list (symbol$ ["" left])
                                                                   (text$ right))))))
                                              inputs))]
                                    (~ (text$ output))
                                    [(~@ (map text$ modifiers))]
                                    (~ body))))))
                         methods)]]
    (emit (@list (` (;_jvm_class (~ (text$ name)) (~ (text$ super))
                                 [(~@ (map text$ interfaces))]
                                 [(~@ fields')]
                                 [(~@ methods')]))))))

(defsyntax #export (program [args symbol^] body)
  (emit (@list (` (;_jvm_program (~ (symbol$ args))
                                 (~ body))))))

(defsyntax #export (??? expr)
  (do Lux/Monad
    [g!val (gensym "")]
    (emit (@list (` (let [(~ g!val) (~ expr)]
                      (if (;_jvm_null? (~ g!val))
                        #;None
                        (#;Some (~ g!val)))))))))

(defsyntax #export (try expr)
  (emit (@list (` (;_jvm_try (#;Right (~ expr))
                             (~ (' (_jvm_catch "java.lang.Exception" e
                                               (#;Left (_jvm_invokevirtual "java.lang.Throwable" "getMessage" [] e []))))))))))

(defsyntax #export (Array [dimensions (?^ int^)] type)
  (let [dimensions (? 1 dimensions)]
    (if (i:> dimensions 0)
      (emit (@list (foldL (lambda [inner _] (` (#;DataT "Array" (@list (~ inner)))))
                          type
                          (repeat dimensions []))))
      (fail "Array must have positive dimension."))))

(defsyntax #export (instance? [class local-symbol^] obj)
  (emit (@list (` (;_jvm_instanceof (~ (text$ class)) (~ obj))))))

(defsyntax #export (locking lock body)
  (do Lux/Monad
    [g!lock (gensym "")
     g!body (gensym "")
     g!_ (gensym "")]
    (emit (@list (` (let [(~ g!lock) (~ lock)
                          (~ g!_) (;_jvm_monitorenter (~ g!lock))
                          (~ g!body) (~ body)
                          (~ g!_) (;_jvm_monitorexit (~ g!lock))]
                      (~ g!body)))))
    ))

(defsyntax #export (null? obj)
  (emit (@list (` (;_jvm_null? (~ obj))))))

(def (prepare-args args)
  (-> (List (, Bool Text)) (Lux (, (List AST) (List AST) (List AST) (List Text))))
  (do Lux/Monad
    [vars (seq% Lux/Monad (repeat (size args) (gensym "")))
     #let [pairings (map (: (-> (, (, Bool Text) AST) (, AST (List AST)))
                            (lambda [[[opt? arg-class] var]]
                              (if opt?
                                [(` (Maybe (^ (~ (symbol$ ["" arg-class])))))
                                 (@list var (` (: (^ (~ (symbol$ ["" arg-class])))
                                                  (case (~ var)
                                                    (#;Some (~ var)) (~ var)
                                                    #;None           ;_jvm_null))))]
                                [(` (^ (~ (symbol$ ["" arg-class]))))
                                 (@list)])))
                         (zip2 args vars))
           var-types (map first pairings)
           var-rebinds (map second pairings)
           arg-classes (map second args)]]
    (wrap [vars var-types (list:join var-rebinds) arg-classes])))

(defsyntax #export (new$ [class local-symbol^] [args (tuple^ (*^ opt-arg^))])
  (do Lux/Monad
    [[vars var-types var-rebinds arg-classes] (prepare-args args)]
    (case vars
      (\ (@list))
      (do Lux/Monad
        [g!_ (gensym "")]
        (wrap (@list (` (: (-> (,) (^ (~ (symbol$ ["" class]))))
                           (lambda [(~ g!_)]
                             (;_jvm_new (~ (text$ class)) [] [])))))))

      _
      (wrap (@list (` (: (-> (, (~@ var-types)) (^ (~ (symbol$ ["" class]))))
                         (lambda [[(~@ vars)]]
                           (let [(~@ var-rebinds)]
                             (;_jvm_new (~ (text$ class)) [(~@ (map text$ arg-classes))] [(~@ vars)])))))))
      )))

(do-template [<name> <op>]
  [(defsyntax #export (<name> [class local-symbol^] [method local-symbol^] [args (tuple^ (*^ opt-arg^))]
                              [ex? (tag?^ ["" "!"])] [opt? (tag?^ ["" "?"])] [return local-symbol^])
     (do Lux/Monad
       [[vars var-types var-rebinds arg-classes] (prepare-args args)
        g!self (gensym "self")
        g!temp (gensym "temp")
        #let [return-type (` (^ (~ (symbol$ ["" return]))))
              body (` (<op> (~ (text$ class)) (~ (text$ method)) [(~@ (map text$ arg-classes))] (~ g!self) [(~@ vars)]))
              [body return-type] (if opt?
                                   [(` (let [(~ g!temp) (~ body)]
                                         (if (;_jvm_null? (~ g!temp))
                                           #;None
                                           (#;Some (~ g!temp)))))
                                    (` (Maybe (~ return-type)))]
                                   [body return-type])
              [body return-type] (if ex?
                                   [(` (try (~ body)))
                                    (` (Either Text (~ return-type)))]
                                   [body return-type])]]
       (wrap (@list (` (: (-> (, (~@ var-types)) (^ (~ (symbol$ ["" class]))) (~ return-type))
                          (lambda [[(~@ vars)] (~ g!self)]
                            (let [(~@ var-rebinds)]
                              (~ body)))))))
       ))]

  [invoke-virtual$   ;_jvm_invokevirtual]
  [invoke-interface$ ;_jvm_invokeinterface]
  )

(defsyntax #export (invoke-static$ [class local-symbol^] [method local-symbol^] [args (tuple^ (*^ opt-arg^))]
                                   [ex? (tag?^ ["" "!"])] [opt? (tag?^ ["" "?"])] [return local-symbol^])
  (do Lux/Monad
    [[vars var-types var-rebinds arg-classes] (prepare-args args)
     g!temp (gensym "temp")
     #let [return-type (` (^ (~ (symbol$ ["" return]))))
           body (` (;_jvm_invokestatic (~ (text$ class)) (~ (text$ method)) [(~@ (map text$ arg-classes))] [(~@ vars)]))
           [body return-type] (if opt?
                                [(` (let [(~ g!temp) (~ body)]
                                      (if (;_jvm_null? (~ g!temp))
                                        #;None
                                        (#;Some (~ g!temp)))))
                                 (` (Maybe (~ return-type)))]
                                [body return-type])
           [body return-type] (if ex?
                                [(` (try (~ body)))
                                 (` (Either Text (~ return-type)))]
                                [body return-type])]]
    (wrap (@list (` (: (-> (, (~@ var-types)) (~ return-type))
                       (lambda [[(~@ vars)]]
                         (let [(~@ var-rebinds)]
                           (~ body)))))))
    ))
