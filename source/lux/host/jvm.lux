##  Copyright (c) Eduardo Julian. All rights reserved.
##  This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
##  If a copy of the MPL was not distributed with this file,
##  You can obtain one at http://mozilla.org/MPL/2.0/.

(;import lux
         (lux (control (monoid #as m)
                       (functor #as F)
                       (monad #as M #refer (#only do)))
              (data (list #refer #all #open ("" List/Functor List/Fold))
                    (number/int #refer #all #open ("i:" Int/Ord))
                    maybe)
              (meta lux
                    ast
                    syntax)))

## [Utils]
## Parsers
(def method-decl^
  (Parser (, (List Text) Text (List Text) Text))
  (form^ (do Parser/Monad
           [modifiers (*^ local-tag^)
            name local-symbol^
            inputs (tuple^ (*^ local-symbol^))
            output local-symbol^]
           (wrap [modifiers name inputs output]))))

(def field-decl^
  (Parser (, (List Text) Text Text))
  (form^ (do Parser/Monad
           [modifiers (*^ local-tag^)
            name local-symbol^
            class local-symbol^]
           (wrap [modifiers name class]))))

(def arg-decl^
  (Parser (, Text Text))
  (form^ (do Parser/Monad
           [arg-name local-symbol^
            arg-class local-symbol^]
           (wrap [arg-name arg-class]))))

(def method-def^
  (Parser (, (List Text) Text (List (, Text Text)) Text AST))
  (form^ (do Parser/Monad
           [modifiers (*^ local-tag^)
            name local-symbol^
            inputs (tuple^ (*^ arg-decl^))
            output local-symbol^
            body id^]
           (wrap [modifiers name inputs output body]))))

## [Syntax]
(defsyntax #export (definterface [name local-symbol^] [supers (tuple^ (*^ local-symbol^))] [members (*^ method-decl^)])
  (let [members' (map (: (-> (, (List Text) Text (List Text) Text) AST)
                         (lambda [member]
                           (let [[modifiers name inputs output] member]
                             (` ((~ (text$ name)) [(~@ (map text$ inputs))] (~ (text$ output)) [(~@ (map text$ modifiers))])))))
                      members)]
    (emit (@list (` (;_jvm_interface (~ (text$ name)) [(~@ (map text$ supers))]
                                     (~@ members')))))))

(defsyntax #export (defclass [name local-symbol^] [super local-symbol^] [interfaces (tuple^ (*^ local-symbol^))]
                     [fields (*^ field-decl^)]
                     [methods (*^ method-def^)])
  (do Lux/Monad
    [current-module get-module-name
     #let [fields' (map (: (-> (, (List Text) Text Text) AST)
                           (lambda [field]
                             (let [[modifiers name class] field]
                               (` ((~ (text$ name))
                                   (~ (text$ class))
                                   [(~@ (map text$ modifiers))])))))
                        fields)
           methods' (map (: (-> (, (List Text) Text (List (, Text Text)) Text AST) AST)
                            (lambda [methods]
                              (let [[modifiers name inputs output body] methods]
                                (` ((~ (text$ name))
                                    [(~@ (map (: (-> (, Text Text) AST)
                                                 (lambda [in]
                                                   (let [[left right] in]
                                                     (form$ (@list (symbol$ ["" left])
                                                                   (text$ right))))))
                                              inputs))]
                                    (~ (text$ output))
                                    [(~@ (map text$ modifiers))]
                                    (~ body))))))
                         methods)]]
    (emit (@list (` (;_jvm_class (~ (text$ name)) (~ (text$ super))
                                 [(~@ (map text$ interfaces))]
                                 [(~@ fields')]
                                 [(~@ methods')]))))))

(defsyntax #export (program [args symbol^] body)
  (emit (@list (` (;_jvm_program (~ (symbol$ args))
                                 (~ body))))))

(defsyntax #export (??? expr)
  (do Lux/Monad
    [g!val (gensym "")]
    (emit (@list (` (let [(~ g!val) (~ expr)]
                      (if (;_jvm_null? (~ g!val))
                        #;None
                        (#;Some (~ g!val)))))))))

(defsyntax #export (try expr)
  (emit (@list (` (;_jvm_try (#;Right (~ expr))
                             (~ (' (_jvm_catch "java.lang.Exception" e
                                               (#;Left (_jvm_invokevirtual "java.lang.Throwable" "getMessage" [] e []))))))))))

(defsyntax #export (Array [dimensions (?^ int^)] type)
  (let [dimensions (? 1 dimensions)]
    (if (i:> dimensions 0)
      (emit (@list (foldL (lambda [inner _] (` (#;DataT "Array" (@list (~ inner)))))
                          type
                          (repeat dimensions []))))
      (fail "Array must have positive dimension."))))
