(import java.lang.System)
(require "./another" as another)

(definterface Function
  (: apply (-> [java.lang.Object] java.lang.Object)))

(defclass Tuple0 [])
(defclass Tuple1 [[java.lang.Object _0]])
(defclass Tuple2 [[java.lang.Object _0] [java.lang.Object _1]])

(defclass Variant [[java.lang.String tag] [java.lang.Object value]])

(def (++ xs ys)
  (case xs
    #Nil
    ys

    (#Cons x xs*)
    (#Cons x (++ xs* ys))))

(def (template elems)
  (case elems
    #Nil
    elems

    (#Cons head tail)
    (case head
      (#Form (#Cons (#Ident "~") (#Cons unquoted #Nil)))
      (#Cons unquoted (template tail))

      (#Form (#Cons (#Ident "~@") (#Cons spliced #Nil)))
      (#Cons (#Ident "++") (#Cons spliced (template tail)))

      _
      (#Cons head (template tail))
      )))

(defmacro (' form)
  (case form
    (#Cons form* #Nil)
    (case form*
      (#Form elems)
      (#Quote (#Form (template elems)))

      _
      (#Quote form*)
      )))

## Utils
(def (fail* message)
  (#Failure message))

(def (return* state value)
  (#Ok state value))

(def (fail message)
  (lambda [state]
     (#Failure message)))

(def (return value)
  (lambda [state]
     (#Ok state value)))

(def (bind m-value step)
  (lambda [state]
     (let inputs (m-value state)
          (case inputs
            (#Ok ?state ?datum)
            (step ?datum ?state)
            
            _
            inputs))))

## Ideally, this is what I want...
## (exec [yolo lol
##        #let [foo bar]
##        #when foo]
##   (meme yolo foo))

(defmacro (exec tokens)
  (case tokens
    (#Cons (#Tuple steps) (#Cons return #Nil))
    (if (= 0 (mod (length steps) 2))
      (fold (lambda [inner pair]
               (case pair
                 [label computation]
                 (` (bind (~ computation)
                          (lambda [(~ label)] (~ inner))))))
            return
            (as-pairs steps))
      (#Text "Oh no!"))))

## Program
(def (main args)
  (case (' ((~ "TROLOLOL")))
    (#Form (#Cons (#Text text) #Nil))
    (:: (:: System out) (println text))
    ))

#(
  (defmacro (::+ pieces)
    (case pieces
      (#Cons init #Nil)
      init

      (#Cons init (#Cons access others))
      (' (::+ (:: (~ init) (~ access)) (~@ others)))
      ))

  (def (main args)
    (if true
      (let f (lambda [x] (lambda [y] (x y)))
           (let g (lambda [x] x)
                (::+ System out (println (f g "WE'VE GOT CLOSURES!")))))
      (:: (:: System out) (println "FALSE"))))

  (def (main args)
    (if true
      (case (++ (#Cons "Pattern" #Nil) (#Cons "Matching" #Nil))
        (#Cons "Pattern" (#Cons second #Nil))
        (do (:: (:: System out) (println "Branch #1"))
          (:: (:: System out) (println second)))

        (#Cons first (#Cons second #Nil))
        (do (:: (:: System out) (println "Branch #2"))
          (:: (:: System out) (println first))
          (:: (:: System out) (println second))))
      (:: (:: System out) (println "FALSE"))))

  (def (main args)
    (case (template (#Cons (#Cons (#Symbol "~@") (#Cons (#Symbol "Pattern") #Nil)) #Nil)
                    ## (#Cons (#Cons (#Symbol "~") (#Cons (#Symbol "Pattern") #Nil)) #Nil)
                       )
      (#Cons word #Nil)
      (do (:: (:: System out) (println "Branch #1"))
        (:: (:: System out) (println word)))

      (#Cons (#Symbol op) spliced)
      (do (:: (:: System out) (println "Branch #2"))
        (:: (:: System out) (println op)))
      ))

  (def (main args)
    (case (' "YOLO")
      (#Text text)
      (:: (:: System out) (println text))))

  (def (main args)
    (case (' ((~ "TROLOLOL")))
      (#Form (#Cons (#Text text) #Nil))
      (:: (:: System out) (println text))
      ))
  )#
