(import java.lang.System)
## (require "./another" as another)

(definterface Function
  (: apply (-> [java.lang.Object] java.lang.Object)))

(defclass Tuple0 [])
(defclass Tuple1 [[java.lang.Object _0]])
(defclass Tuple2 [[java.lang.Object _0] [java.lang.Object _1]])

(defclass Variant [[java.lang.String tag] [java.lang.Object value]])

(def (++ xs ys)
  (case xs
    #Nil
    ys

    (#Cons x xs*)
    (#Cons x (++ xs* ys))))

(def (template elems)
  (case elems
    #Nil
    elems

    (#Cons head tail)
    (case head
      (#Form (#Cons (#Ident "~") (#Cons unquoted #Nil)))
      (#Cons unquoted (template tail))

      (#Form (#Cons (#Ident "~@") (#Cons spliced #Nil)))
      (#Cons (#Ident "++") (#Cons spliced (template tail)))

      _
      (#Cons head (template tail))
      )))

(defmacro (' form)
  (case form
    (#Cons form* #Nil)
    (case form*
      (#Form elems)
      (#Quote (#Form (template elems)))

      _
      (#Quote form*)
      )))

(def (main args)
  (case (' ((~ "TROLOLOL")))
    (#Form (#Cons (#Text text) #Nil))
    (:: (:: System out) (println text))
    ))

#(
  (defmacro (::+ pieces)
    (case pieces
      (#Cons init #Nil)
      init

      (#Cons init (#Cons access others))
      (' (::+ (:: (~ init) (~ access)) (~@ others)))
      ))

  (def (main args)
    (if true
      (let f (lambda [x] (lambda [y] (x y)))
           (let g (lambda [x] x)
                (::+ System out (println (f g "WE'VE GOT CLOSURES!")))))
      (:: (:: System out) (println "FALSE"))))

  (def (main args)
    (if true
      (case (++ (#Cons "Pattern" #Nil) (#Cons "Matching" #Nil))
        (#Cons "Pattern" (#Cons second #Nil))
        (do (:: (:: System out) (println "Branch #1"))
          (:: (:: System out) (println second)))

        (#Cons first (#Cons second #Nil))
        (do (:: (:: System out) (println "Branch #2"))
          (:: (:: System out) (println first))
          (:: (:: System out) (println second))))
      (:: (:: System out) (println "FALSE"))))

  (def (main args)
    (case (template (#Cons (#Cons (#Symbol "~@") (#Cons (#Symbol "Pattern") #Nil)) #Nil)
                    ## (#Cons (#Cons (#Symbol "~") (#Cons (#Symbol "Pattern") #Nil)) #Nil)
                       )
      (#Cons word #Nil)
      (do (:: (:: System out) (println "Branch #1"))
        (:: (:: System out) (println word)))

      (#Cons (#Symbol op) spliced)
      (do (:: (:: System out) (println "Branch #2"))
        (:: (:: System out) (println op)))
      ))

  (def (main args)
    (case (' "YOLO")
      (#Text text)
      (:: (:: System out) (println text))))

  (def (main args)
    (case (' ((~ "TROLOLOL")))
      (#Form (#Cons (#Text text) #Nil))
      (:: (:: System out) (println text))
      ))
  )#
