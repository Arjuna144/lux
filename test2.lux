(import java.lang.System)
## (use "./another" as another)

(jvm/definterface Function
  (: apply (-> [java.lang.Object] java.lang.Object)))

(jvm/defclass Tuple0 java.lang.Object
  [])
(jvm/defclass Tuple1 java.lang.Object
  [[java.lang.Object _1]])
(jvm/defclass Tuple2 java.lang.Object
  [[java.lang.Object _1] [java.lang.Object _2]])
(jvm/defclass Tuple3 java.lang.Object
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3]])
(jvm/defclass Tuple4 java.lang.Object
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3] [java.lang.Object _4]])
(jvm/defclass Tuple5 java.lang.Object
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3] [java.lang.Object _4]
   [java.lang.Object _5]])
(jvm/defclass Tuple6 java.lang.Object
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3] [java.lang.Object _4]
   [java.lang.Object _5] [java.lang.Object _6]])
(jvm/defclass Tuple7 java.lang.Object
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3] [java.lang.Object _4]
   [java.lang.Object _5] [java.lang.Object _6]
   [java.lang.Object _7]])
(jvm/defclass Tuple8 java.lang.Object
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3] [java.lang.Object _4]
   [java.lang.Object _5] [java.lang.Object _6]
   [java.lang.Object _7] [java.lang.Object _8]])

(jvm/defclass Variant java.lang.Object
  [[java.lang.String tag]])
(jvm/defclass Variant0 test2.Variant
  [])
(jvm/defclass Variant1 test2.Variant
  [[java.lang.Object _1]])
(jvm/defclass Variant2 test2.Variant
  [[java.lang.Object _1] [java.lang.Object _2]])
(jvm/defclass Variant3 test2.Variant
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3]])
(jvm/defclass Variant4 test2.Variant
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3] [java.lang.Object _4]])
(jvm/defclass Variant5 test2.Variant
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3] [java.lang.Object _4]
   [java.lang.Object _5]])
(jvm/defclass Variant6 test2.Variant
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3] [java.lang.Object _4]
   [java.lang.Object _5] [java.lang.Object _6]])
(jvm/defclass Variant7 test2.Variant
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3] [java.lang.Object _4]
   [java.lang.Object _5] [java.lang.Object _6]
   [java.lang.Object _7]])
(jvm/defclass Variant8 test2.Variant
  [[java.lang.Object _1] [java.lang.Object _2]
   [java.lang.Object _3] [java.lang.Object _4]
   [java.lang.Object _5] [java.lang.Object _6]
   [java.lang.Object _7] [java.lang.Object _8]])

(def (++ xs ys)
  (case xs
    #Nil
    ys

    (#Cons x xs*)
    (#Cons x (++ xs* ys))))

(def (template elems)
  (case elems
    #Nil
    elems

    (#Cons head tail)
    (case head
      (#Form (#Cons (#Ident "~") (#Cons unquoted #Nil)))
      (#Cons unquoted (template tail))

      (#Form (#Cons (#Ident "~@") (#Cons spliced #Nil)))
      (#Cons (#Ident "++") (#Cons spliced (template tail)))

      _
      (#Cons head (template tail))
      )))

(defmacro (' form)
  (case form
    (#Cons form* #Nil)
    (case form*
      (#Form elems)
      (#Quote (#Form (template elems)))

      _
      (#Quote form*)
      )))

## Utils
(def (fail* message)
  (#Failure message))

(def (return* state value)
  (#Ok state value))

(def (fail message)
  (lambda [state]
     (#Failure message)))

(def (return value)
  (lambda [state]
     (#Ok state value)))

(def (bind m-value step)
  (lambda [state]
     (let inputs (m-value state)
          (case inputs
            (#Ok ?state ?datum)
            (step ?datum ?state)
            
            _
            inputs))))

## Ideally, this is what I want...
## (exec [yolo lol
##        #let [foo (bar 1 2 3)]
##        #when true]
##   (meme yolo foo))

(def (+ x y)
  (jvm/i+ x y))

(def inc (+ 1))

#( 
   

   (def (fold f init values)
     (case values
       #Nil
       init
       (#Cons x xs)
       (fold f (f init x) xs)))

   (def length (fold inc 0))

   (def (mod dividend divisor)
     (jvm/imod dividend divisor))

   (def (= x y)
     (.equals x y))

   (def (as-pairs list)
     (case list
       (#Cons x (#Cons y list*))
       (#Cons [x y] (as-pairs list*))

       _
       #Nil))

   (defmacro (exec tokens)
     (case tokens
       (#Cons (#Tuple steps) (#Cons return #Nil))
       (if (= 0 (mod (length steps) 2))
         (fold (lambda [inner pair]
                  (case pair
                    [label computation]
                    (` (bind (~ computation)
                             (lambda [(~ label)] (~ inner))))))
               return
               (as-pairs steps))
         (#Text "Oh no!")))) )#

## Program
(def (main args)
  (case (' ((~ "Oh yeah...")))
    (#Form (#Cons (#Text text) #Nil))
    (do (:: (:: System out) (println text))
      (:: (:: System out) (println (+ 10 20)))
      (:: (:: System out) (println (inc 10)))
      (:: (:: System out) (println (jvm/i- 10 20)))
      (:: (:: System out) (println (jvm/i* 10 20)))
      (:: (:: System out) (println (jvm/i/ 10 2))))
    ))

#(
  (def (main args)
    (case (' ((~ "Oh yeah...")))
      (#Form (#Cons (#Text text) #Nil))
      (do (jvm/invokevirtual (jvm/getstatic System out)
                             java.io.PrintStream "println" [String]
                             [text])
        (jvm/invokevirtual (jvm/getstatic System out)
                           java.io.PrintStream "println" [Object]
                           [(+ 10 20)])
        (jvm/invokevirtual (jvm/getstatic System out)
                           java.io.PrintStream "println" [Object]
                           [(inc 10)])
        (jvm/invokevirtual (jvm/getstatic System out)
                           java.io.PrintStream "println" [Object]
                           [(jvm/i- 10 20)])
        (jvm/invokevirtual (jvm/getstatic System out)
                           java.io.PrintStream "println" [Object]
                           [(jvm/i* 10 20)])
        (jvm/invokevirtual (jvm/getstatic System out)
                           java.io.PrintStream "println" [Object]
                           [(jvm/i/ 10 2)]))
      ))
  
  (defmacro (::+ pieces)
    (case pieces
      (#Cons init #Nil)
      init

      (#Cons init (#Cons access others))
      (' (::+ (:: (~ init) (~ access)) (~@ others)))
      ))

  (def (main args)
    (if true
      (let f (lambda [x] (lambda [y] (x y)))
           (let g (lambda [x] x)
                (::+ System out (println (f g "WE'VE GOT CLOSURES!")))))
      (:: (:: System out) (println "FALSE"))))

  (def (main args)
    (if true
      (case (++ (#Cons "Pattern" #Nil) (#Cons "Matching" #Nil))
        (#Cons "Pattern" (#Cons second #Nil))
        (do (:: (:: System out) (println "Branch #1"))
          (:: (:: System out) (println second)))

        (#Cons first (#Cons second #Nil))
        (do (:: (:: System out) (println "Branch #2"))
          (:: (:: System out) (println first))
          (:: (:: System out) (println second))))
      (:: (:: System out) (println "FALSE"))))

  (def (main args)
    (case (template (#Cons (#Cons (#Symbol "~@") (#Cons (#Symbol "Pattern") #Nil)) #Nil)
                    ## (#Cons (#Cons (#Symbol "~") (#Cons (#Symbol "Pattern") #Nil)) #Nil)
                       )
      (#Cons word #Nil)
      (do (:: (:: System out) (println "Branch #1"))
        (:: (:: System out) (println word)))

      (#Cons (#Symbol op) spliced)
      (do (:: (:: System out) (println "Branch #2"))
        (:: (:: System out) (println op)))
      ))

  (def (main args)
    (case (' "YOLO")
      (#Text text)
      (:: (:: System out) (println text))))

  (def (main args)
    (case (' ((~ "TROLOLOL")))
      (#Form (#Cons (#Text text) #Nil))
      (:: (:: System out) (println text))
      ))
  )#
